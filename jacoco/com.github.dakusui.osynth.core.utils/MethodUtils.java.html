<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MethodUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">osynth</a> &gt; <a href="index.source.html" class="el_package">com.github.dakusui.osynth.core.utils</a> &gt; <span class="el_source">MethodUtils.java</span></div><h1>MethodUtils.java</h1><pre class="source lang-java linenums">package com.github.dakusui.osynth.core.utils;

import com.github.dakusui.osynth.core.InvocationController;
import com.github.dakusui.osynth.core.MethodHandler;
import com.github.dakusui.osynth.core.MethodSignature;
import com.github.dakusui.osynth.core.SynthesizedObject;
import com.github.dakusui.osynth.exceptions.OsynthException;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Stream;

import static com.github.dakusui.osynth.core.utils.MessageUtils.messageForMissingMethodHandler;
import static com.github.dakusui.pcond.forms.Predicates.isNotNull;
import static com.github.dakusui.pcond.forms.Predicates.transform;
import static com.github.dakusui.valid8j.Assertions.that;
import static java.util.stream.Collectors.joining;

<span class="pc bpc" id="L26" title="1 of 2 branches missed.">public enum MethodUtils {</span>
  ;

  public static MethodHandler createMethodHandlerFromFallbackObject(final Object fallbackObject, MethodSignature methodSignature) {
<span class="pc bpc" id="L30" title="2 of 4 branches missed.">    assert that(fallbackObject, isNotNull());</span>
<span class="fc" id="L31">    return createMethodHandlerDelegatingToObject(fallbackObject, methodSignature);</span>
  }

  public static MethodHandler createMethodHandlerDelegatingToObject(Object object, MethodSignature methodSignature) {
<span class="pc bpc" id="L35" title="2 of 4 branches missed.">    assert object != null;</span>
<span class="fc" id="L36">    return (synthesizedObject, args) -&gt; execute(() -&gt; {</span>
<span class="fc" id="L37">      Method method = getMethodFromClass(synthesizedObject, object.getClass(), methodSignature.name(), methodSignature.parameterTypes());</span>
<span class="fc" id="L38">      method.setAccessible(true);</span>
<span class="fc" id="L39">      return method.invoke(object, args);</span>
    });
  }

  public static Optional&lt;MethodHandler&gt; createMethodHandlerFromInterfaceClass(Class&lt;?&gt; fromClass, MethodSignature methodSignature) {
<span class="fc" id="L44">    return findMethodHandleFor(methodSignature, fromClass).map(MethodUtils::toMethodHandler);</span>
  }

  static MethodHandler toMethodHandler(MethodHandle methodHandle) {
<span class="fc" id="L48">    return (SynthesizedObject synthesizedObject, Object[] arguments) -&gt; execute(</span>
<span class="fc" id="L49">        () -&gt; methodHandle.bindTo(synthesizedObject).invokeWithArguments(arguments));</span>
  }

  static Optional&lt;MethodHandle&gt; findMethodHandleFor(MethodSignature methodSignature, Class&lt;?&gt; fromClass) {
<span class="fc" id="L53">    return findMethodMatchingWith(methodSignature, fromClass).filter(Method::isDefault).map(m -&gt; methodHandleFor(m, fromClass));</span>
  }

  private static MethodHandle methodHandleFor(Method m, Class&lt;?&gt; fromClass) {
<span class="pc bpc" id="L57" title="2 of 4 branches missed.">    assert that(fromClass, transform(AssertionUtils.classGetMethod(m.getName(), m.getParameterTypes())).check(isNotNull()));</span>
<span class="fc" id="L58">    return execute(() -&gt; createMethodHandlesLookupFor(fromClass).in(fromClass).unreflectSpecial(m, fromClass));</span>
  }

  public static synchronized MethodHandles.Lookup createMethodHandlesLookupFor(Class&lt;?&gt; anInterfaceClass) {
<span class="fc" id="L62">    return execute(() -&gt; {</span>
      Constructor&lt;MethodHandles.Lookup&gt; constructor;
<span class="fc" id="L64">      constructor = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class);</span>
<span class="fc" id="L65">      constructor.setAccessible(true);</span>
<span class="fc" id="L66">      return constructor.newInstance(anInterfaceClass);</span>
    });
  }

  /**
   * A method to uniform a way to handle exceptions.
   *
   * @param block A block to execute hand to handle possible exceptions.
   * @param &lt;T&gt;   A type of the returned value.
   * @return A returned value from the block.
   */
  public static &lt;T&gt; T execute(FailableSupplier&lt;T&gt; block) {
<span class="fc" id="L78">    return execute(block, Throwable::getMessage);</span>
  }

  public static &lt;T&gt; T execute(FailableSupplier&lt;T&gt; block, Function&lt;Throwable, String&gt; messageComposerOnFailure) {
    try {
<span class="fc" id="L83">      return block.get();</span>
<span class="fc" id="L84">    } catch (Error e) {</span>
<span class="fc" id="L85">      throw e;</span>
<span class="fc" id="L86">    } catch (Throwable e) {</span>
<span class="nc" id="L87">      throw OsynthException.from(messageComposerOnFailure.apply(e), e);</span>
    }
  }

  public static Object[] toEmptyArrayIfNull(Object[] args) {
<span class="fc bfc" id="L92" title="All 2 branches covered.">    if (args == null)</span>
<span class="fc" id="L93">      return InvocationController.EMPTY_ARGS;</span>
<span class="fc" id="L94">    return args;</span>
  }

  public static Optional&lt;MethodHandler&gt; createMethodHandlerFromInterfaces(List&lt;Class&lt;?&gt;&gt; interfaces, MethodSignature methodSignature) {
<span class="fc" id="L98">    return interfaces.stream()</span>
<span class="fc" id="L99">        .map((Class&lt;?&gt; eachInterfaceClass) -&gt; createMethodHandlerFromInterfaceClass(eachInterfaceClass, methodSignature))</span>
<span class="fc" id="L100">        .filter(Optional::isPresent)</span>
<span class="fc" id="L101">        .map(Optional::get)</span>
<span class="fc" id="L102">        .findFirst();</span>
  }

  public static boolean isToStringOverridden(Class&lt;?&gt; aClass) {
<span class="fc bfc" id="L106" title="All 2 branches covered.">    return !getMethodFromClass(aClass, &quot;toString&quot;).getDeclaringClass().equals(Object.class);</span>
  }

  public static Method getMethodFromClass(Class&lt;?&gt; aClass, String methodName, Class&lt;?&gt;... parameterTypes) {
<span class="fc" id="L110">    return getMethodFromClass(aClass, aClass, methodName, parameterTypes);</span>
  }

  private static Method getMethodFromClass(Object objectForErrorMessageFormatting, Class&lt;?&gt; aClass, String methodName, Class&lt;?&gt;... parameterTypes) {
    try {
<span class="fc" id="L115">      return aClass.getMethod(methodName, parameterTypes);</span>
<span class="fc" id="L116">    } catch (NoSuchMethodException e) {</span>
<span class="fc" id="L117">      throw new UnsupportedOperationException(messageForMissingMethodHandler(methodName, parameterTypes, objectForErrorMessageFormatting, e), e);</span>
    }
  }

  public static String simpleClassNameOf(Class&lt;?&gt; aClass) {
<span class="fc bfc" id="L122" title="All 4 branches covered.">    if (aClass.getSimpleName().length() &gt; 0 &amp;&amp; !aClass.isSynthetic())</span>
<span class="fc" id="L123">      return aClass.getSimpleName();</span>
    final String label;
    final Optional&lt;String&gt; m;
<span class="fc bfc" id="L126" title="All 2 branches covered.">    if (aClass.isSynthetic()) {</span>
<span class="fc" id="L127">      label = &quot;lambda&quot;;</span>
<span class="fc" id="L128">      m = Optional.of(enclosingClassNameOfLambda(aClass.getCanonicalName()));</span>
    } else {
<span class="fc" id="L130">      label = &quot;anonymous&quot;;</span>
<span class="fc" id="L131">      m = Optional.empty();</span>
    }
<span class="fc" id="L133">    return streamSupertypes(aClass)</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        .filter(each -&gt; !Objects.equals(Object.class, each))</span>
<span class="fc" id="L135">        .map(MethodUtils::simpleClassNameOf)</span>
<span class="fc" id="L136">        .collect(joining(&quot;,&quot;, label + &quot;:(&quot;, &quot;)&quot;)) +</span>
<span class="fc" id="L137">        m.map(v -&gt; &quot;:declared in &quot; + v).orElse(&quot;&quot;);</span>
  }

  public static String prettierToString(Object object) {
<span class="fc bfc" id="L141" title="All 2 branches covered.">    if (object == null)</span>
<span class="fc" id="L142">      return &quot;null&quot;;</span>
<span class="fc" id="L143">    Class&lt;?&gt; aClass = object.getClass();</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">    return isToStringOverridden(aClass) ?</span>
<span class="fc" id="L145">        object.toString() :</span>
<span class="fc" id="L146">        simpleClassNameOf(aClass) + &quot;@&quot; + System.identityHashCode(object);</span>
  }

  private static String enclosingClassNameOfLambda(String canonicalNameOfLambda) {
<span class="fc" id="L150">    String ret = canonicalNameOfLambda.substring(0, canonicalNameOfLambda.lastIndexOf(&quot;$$&quot;));</span>
<span class="fc" id="L151">    int b = ret.lastIndexOf(&quot;$&quot;);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">    if (b &lt; 0)</span>
<span class="fc" id="L153">      return ret;</span>
<span class="fc" id="L154">    return ret.substring(b + &quot;$&quot;.length());</span>
  }

  private static Stream&lt;Class&lt;?&gt;&gt; streamSupertypes(Class&lt;?&gt; klass) {
<span class="fc" id="L158">    return Stream.concat(</span>
<span class="fc" id="L159">            Stream.of(klass.getSuperclass()),</span>
<span class="fc" id="L160">            Arrays.stream(klass.getInterfaces()))</span>
<span class="fc" id="L161">        .filter(Objects::nonNull);</span>
  }

  /**
   * An interface to define a block which possibly throws an exception.
   * Intended to be used with {@link MethodUtils#execute} method.
   *
   * @param &lt;T&gt; A type of the value retuned by the block.
   */
  public interface FailableSupplier&lt;T&gt; {
    T get() throws Throwable;
  }

  private static Optional&lt;Method&gt; findMethodMatchingWith(MethodSignature methodSignature, Class&lt;?&gt; fromClass) {
    try {
<span class="fc" id="L176">      return Optional.of(fromClass.getMethod(methodSignature.name(), methodSignature.parameterTypes()));</span>
<span class="fc" id="L177">    } catch (NoSuchMethodException e) {</span>
<span class="fc" id="L178">      return Optional.empty();</span>
    }
  }

  public static MethodHandler withName(String name, MethodHandler methodHandler) {
<span class="fc" id="L183">    return new MethodHandler() {</span>
      @Override
      public Object handle(SynthesizedObject synthesizedObject, Object[] objects) throws Throwable {
<span class="fc" id="L186">        return methodHandler.handle(synthesizedObject, objects);</span>
      }

      @Override
      public String toString() {
<span class="fc" id="L191">        return name;</span>
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>