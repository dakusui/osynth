[plantuml]
----
class SynthesizeObject {
  List<MethodHandler> methodHandlers()
  List<Interfaces>    interfaces()
  Optional<Object>    fallbackObject()
}

class A2 extends SynthesizedObject {
}

object "a2Object:A2" as a2 {
}

firstObject::SynthesizedObject *--> SynthesizedObject

SynthesizedObject *--> SynthesizedObject
----

When a method invocation request is received,

1. Try to find the narrowest possible matching method handler from `methodHandlers()`.
2. Try to find the matching default implementation in the `interfaces()`.
3. If a `fallbackObject` is present, a method invocation will be attempted on it.

Note that the `fallbackObject` can be another synthesized object.

== Inside a `MethodHandler`

How to make a call within the same synthesized object.

== Methods in `java.lang.Object` class

Methods declared in `java.lang.Object` are always available for all the objects in Java.
Therefore, for the proxy objects synthesized by our `osynth` library, you can also call them.

[text]
.Methods defined in `java.lang.Object`.
----
+-------- public
|+------- protected
||+------ private
|||
|||  +--- final
|||  |+-- native
|||  ||+- static
|||  |||
X    XX  getClass []
X    XX  notify []
X    XX  notifyAll []
X    X   wait [long, int]
X    XX  wait [long]
X    X   wait []
X     X  hashCode []
X        equals [class java.lang.Object]
X        toString []
 X    X  clone []
 X       finalize []
  X   XX registerNatives []
----

Some methods defined in `java.lang.Object` are treated by the dynamic proxy mechanism of Java's core API<<Proxy>>.
When they are called, the method call request is intercepted by the dynamic proxy mechanism and passed to your invocation handler.
This allows us to customize the behaviors of these methods but at the same time we need appropriately to take care of situations , where such method calls are made from inside the invocation handler itself.
Otherwise, the call makes another call on the same method, which results in the infinite recursive call and `StackOverflow` error.
More notably, such a specification is defined for `hashCode()`, `equals(Object)`, and `toString()` methods, which are called implicitly.

The `osynth` library has its own built-in method handlers for those methods, which serve as default behaviors for a synthesized object.

== The structure of a "synthesized object"

[plantuml]
----
hide empty members
top to bottom direction

interface "BiFunction<SynthesizedObject,Object[],Object>" as bf1 {
}
class "Class<?>" as cl1 {
}
class "Object" as obj1 {
}
interface "SynthesizedObject" as so1 {
  {abstract} +List<Class<?>> interfaces()
  {abstract} +MethodHandler methodHandlerFor(MethodSignature)
  {abstract} +Object fallbackObject()
}
interface "MethodHandler" as mh1 extends bf1 {
}
interface "SynthesizedObject" as so2 {
}

so1 "1" --> "*" mh1
so1 "1" --> "*" cl1: interfaces
so1 "1" --> "1" obj1: fallbackObject
----

[source]
----
hide empty members
top to bottom direction

interface SynthesizedObject {
  {abstract} +List<Class<?>> interfaces()
  {abstract} +MethodHandler methodHandlerFor(MethodSignature)
}
interface MethodHandler {
}
class Class<?> {
}
class Object {
}
object "synthesizedObject::SynthesizedObject" as SynthesizedObject {
}
object "fallbackSynthesizedObject::SynthesizedObject" as SynthesizedObject {
}
object "fallbackObject::Object" as Object {
}
object "interface::Class<?>" as Class {
}
object "methodHandler::MethodHandler" as MethodHandler {
}

SynthesizedObject <|-- synthesizedObject
MethodHandler <|-- methodHandler
synthesizedObject "methodHandlers" o--> methodHandler
synthesizedObject "1" --> "*" interface
synthesizedObject "1" --> "1" fallbackSynthesizedObject
fallbackSynthesizedObject "methodHandlers" o--> methodHandlerForFallbackSynthesiedObject
fallbackSynthesizedObject "1" --> "*" interfaceForFallbackSynthesiedObject
fallbackSynthesizedObject "1" --> "1" fallbackObject
----


== Method Dispatching Mechanism

A method invocation can be handled in three ways.

1. Search for a method handler.
2. If an appropriate method handler is not found, `default` method is searched.
3. If any `default` method is not found, then the request is delegated to "fallback object".

Throughout these steps, methods are identified by its name and parameter types *only* and their declaring classes and returning types do not matter.
That is, even if a method invocation happens for `InterfaceA#methodA(String)`, it might be handled by a `default` method defined as `InterfaceB#methodA(String)`.
In case the returning type does not match with the calling side intended (in the case above, suppose that the `InterfaceA#methodA(String)` is returning `int`, but the `InterfaceB#methodA(String)` is returning `Set<Integer>`), it will result in a runtime error.

=== Method Handlers

(t.b.d.)

=== `default` methods

(t.b.d.)

=== The fall-backing mechanism

When no appropriate way to handle a method call is found in the current synthesized object, the `osynth` delegates the procedure to its "fallback object".
The fallback object might be either a conventional Java object or another synthesized object.
The delegation happens using a reflection.
The current synthesized object tries to find a method by name and parameter types in the fallback object.


== References

- [[[Proxy, 1]]] "Proxy (Java Platform SE 8)" https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html